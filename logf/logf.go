package logf

import (
	"errors"
	"fmt"
	"github.com/woshikedayaa/waveform-backend/config"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"os"
	"path/filepath"
	"strings"
	"time"
)

// 日志初始化函数
func LoggerInit() error {
	var (
		err error

		encoderConfig zapcore.EncoderConfig
		encoder       zapcore.Encoder
		writer        zapcore.WriteSyncer
		format        string = strings.ToLower(config.G().Log.Format)
	)
	// 检查是否需要输出日志，如果没有指定输出，则直接返回
	if len(config.G().Log.Output) == 0 {
		return nil
	}

	// 配置 encoderConfig 和 encoder
	encoderConfig = zapcore.EncoderConfig{
		MessageKey:     "msg",
		LevelKey:       "level",
		TimeKey:        "ts",
		NameKey:        "logger",
		EncodeDuration: zapcore.StringDurationEncoder,
		EncodeLevel:    zapcore.CapitalLevelEncoder,
	}

	if format == "json" {

		encoderConfig.EncodeTime = func(t time.Time, enc zapcore.PrimitiveArrayEncoder) {
			//这里是 json 格式的 解析 毫秒
			enc.AppendInt64(t.UnixMilli())
		}

		encoder = zapcore.NewJSONEncoder(encoderConfig)
	} else if format == "console" {

		encoderConfig.EncodeTime = func(t time.Time, enc zapcore.PrimitiveArrayEncoder) {
			// 这个是 zap官方库里面的实现 稍微修改了一下
			layout := time.DateTime
			type appendTimeEncoder interface {
				AppendTimeLayout(time.Time, string)
			}
			if enc, ok := enc.(appendTimeEncoder); ok {
				enc.AppendTimeLayout(t, layout)
				return
			}
			enc.AppendString(t.Format(layout))
		}

		encoder = zapcore.NewConsoleEncoder(encoderConfig)
	} else if format == "console_with_color" {
		encoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
		encoderConfig.EncodeTime = func(t time.Time, enc zapcore.PrimitiveArrayEncoder) {
			// 这个是 zap官方库里面的实现 稍微修改了一下
			layout := time.DateTime
			type appendTimeEncoder interface {
				AppendTimeLayout(time.Time, string)
			}
			if enc, ok := enc.(appendTimeEncoder); ok {
				enc.AppendTimeLayout(t, layout)
				return
			}
			enc.AppendString(t.Format(layout))
		}

		encoder = zapcore.NewConsoleEncoder(encoderConfig)
	} else {
		return errors.New(fmt.Sprintf("logf: 不支持的格式 format %s", format))
	}
	//
	// 配置 Writer

	writer, err = getWriter(config.G().Log.Output)
	// 配置 core

	level, err := zapcore.ParseLevel(config.G().Log.Level)
	if err != nil {
		return errors.New("logf: " + err.Error())
	}
	core = zapcore.NewCore(encoder, writer, zap.LevelEnablerFunc(func(l zapcore.Level) bool {
		if len(config.G().Log.ErrOutput) >= 1 {
			// 如果启用了error 和 普通日志分流就把error日志输出到 errOutput 配置项
			return l >= level && l < zapcore.ErrorLevel
		}
		return l >= level
	}))

	// 配置 errCore
	if level <= zapcore.ErrorLevel && len(config.G().Log.ErrOutput) >= 1 {
		ew, err := getWriter(config.G().Log.ErrOutput)
		if err != nil {
			return errors.New("logf: " + err.Error())
		}
		core = zapcore.NewTee(core, zapcore.NewCore(encoder, ew, zap.LevelEnablerFunc(func(l zapcore.Level) bool {
			return l >= zapcore.ErrorLevel
		})))
	}

	// 配置 options
	err = optionsInit()
	if err != nil {
		return errors.New("logf: " + err.Error())
	}

	// 结束
	return nil
}

func getWriter(ss []string) (zapcore.WriteSyncer, error) {
	var writers []zapcore.WriteSyncer
	for i := 0; i < len(ss); i++ {
		target := ss[i]
		switch target {
		case "stdout":
			writers = append(writers, zapcore.WriteSyncer(os.Stdout))
		case "stderr":
			writers = append(writers, zapcore.WriteSyncer(os.Stderr))
		case "":
			continue
		default:
			dir := filepath.Dir(target)
			err := os.MkdirAll(dir, 0755) // rwxrw-rw-
			if err != nil {
				return nil, err
			}

			file, err := os.OpenFile(target, os.O_WRONLY|os.O_CREATE|os.O_SYNC, 0644) // rw-r--r--
			if err != nil {
				return nil, err
			}
			writers = append(writers, zapcore.WriteSyncer(file))
		}
	}
	return zapcore.NewMultiWriteSyncer(writers...), nil
}

func optionsInit() error {
	// error output 移除的原因 刚开始以为是 不同等级的日志定向 后面发现是 zap的错误日志记录
	// 原文
	/*
		// ErrorOutput sets the destination for errors generated by the Logger. Note
		// that this option only affects internal errors;
	*/

	// error output
	//ew, err := getWriter(config.G().Log.ErrOutput)
	//if err != nil {
	//	return err
	//}
	//options = append(options, zap.ErrorOutput(ew))
	return nil
}
